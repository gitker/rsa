#include "rsa.h"

typedef unsigned long ulong;
typedef struct
{
    unsigned char *heap_memory;
    unsigned int max_len;
    unsigned int heap_total;

} memctrl;

#define ciL (sizeof(mbedtls_mpi_uint)) /* chars in limb  */
#define biL (ciL << 3)                 /* bits  in limb  */

#define CHARS_TO_LIMBS(i) ((i) / ciL + ((i) % ciL != 0))

void *mcpy(void *dest, const void *src, ulong count)
{
    unsigned long *dl = (unsigned long *)dest, *sl = (unsigned long *)src;
    char *d8, *s8;

    if ((((unsigned long)dest | (unsigned long)src) & (sizeof(*dl) - 1)) == 0)
    {
        while (count >= sizeof(*dl))
        {
            *dl++ = *sl++;
            count -= sizeof(*dl);
        }
    }

    d8 = (char *)dl;
    s8 = (char *)sl;
    while (count--)
        *d8++ = *s8++;

    return dest;
}

void *clear(void *s, ulong count)
{
    unsigned long *sl = (unsigned long *)s;
    char *s8;

    if (((unsigned long)s & (sizeof(*sl) - 1)) == 0)
    {
        while (count >= sizeof(*sl))
        {
            *sl++ = 0;
            count -= sizeof(*sl);
        }
    }

    s8 = (char *)sl;
    while (count--)
        *s8++ = 0;

    return s;
}

static memctrl *mbedtls_set_heap(unsigned char *mem, int maxsize)
{
    memctrl *mctl = (memctrl *)mem;

    mctl->heap_memory = mem + sizeof(memctrl);
    mctl->max_len = maxsize - sizeof(memctrl);
    mctl->heap_total = 0;

    return mctl;
}

static void *mbedtls_calloc(memctrl *ctl, ulong size)
{
    void *addr = ctl->heap_memory + ctl->heap_total;

    if (ctl->heap_total + size > ctl->max_len)
    {
        return 0;
    }
    clear(addr, size);
    ctl->heap_total += size;
    return addr;
}

int mbedtls_mpi_alloc(memctrl *ctl, mbedtls_mpi *X, ulong nblimbs)
{
    X->p = (mbedtls_mpi_uint *)mbedtls_calloc(ctl, nblimbs * ciL);

    if (X->p == 0)
        return (MBEDTLS_ERR_MPI_ALLOC_FAILED);

    X->n = nblimbs;

    X->s = 1;

    return (0);
}

static inline mbedtls_mpi_uint mpi_sub_hlp(ulong n,
                                           mbedtls_mpi_uint *d,
                                           const mbedtls_mpi_uint *s)
{
    ulong i;
    mbedtls_mpi_uint c, z;

    for (i = c = 0; i < n; i++, s++, d++)
    {
        z = (*d < c);
        *d -= c;
        c = (*d < *s) + z;
        *d -= *s;
    }

    return (c);
}

static void mpi_mul_hlp(ulong i, mbedtls_mpi_uint *s, mbedtls_mpi_uint *d, mbedtls_mpi_uint b)
{
    mbedtls_mpi_uint c = 0, t = 0;

    for (; i >= 8; i -= 8)
    {
        MULADDC_INIT
        MULADDC_CORE MULADDC_CORE MULADDC_CORE MULADDC_CORE
        MULADDC_CORE MULADDC_CORE MULADDC_CORE MULADDC_CORE
        MULADDC_STOP
    }

    for (; i > 0; i--)
    {
        MULADDC_INIT
        MULADDC_CORE
        MULADDC_STOP
    }
    t++;

    do
    {
        *d += c;
        c = (*d < c);
        d++;
    } while (c != 0);
}

static void mpi_safe_cond_assign(ulong n,
                                 mbedtls_mpi_uint *dest,
                                 const mbedtls_mpi_uint *src,
                                 unsigned char assign)
{
    ulong i;
    for (i = 0; i < n; i++)
        dest[i] = dest[i] * (1 - assign) + src[i] * assign;
}

/*
 * Fast Montgomery initialization (thanks to Tom St Denis)
 */
static void mpi_montg_init(mbedtls_mpi_uint *mm, const mbedtls_mpi *N)
{
    mbedtls_mpi_uint x, m0 = N->p[0];
    unsigned int i;

    x = m0;
    x += ((m0 + 2) & 4) << 1; // x = n^-1 mod 16

    // N^-1(mod 2^2m) = N^-1(mod 2^m) × ( 2 - N ×  N^-1(mod 2^m))
    for (i = biL; i >= 8; i /= 2)
        x *= (2 - (m0 * x));

    *mm = ~x + 1;
}

static void mpi_montmul(mbedtls_mpi *A, const mbedtls_mpi *B, const mbedtls_mpi *N, mbedtls_mpi_uint mm,
                        const mbedtls_mpi *T)
{
    ulong i, n, m;
    mbedtls_mpi_uint u0, u1, *d;

    clear(T->p, T->n * ciL);

    d = T->p;
    n = N->n;
    m = (B->n < n) ? B->n : n;

    for (i = 0; i < n; i++)
    {
        /*
         * T = (T + u0*B + u1*N) / 2^biL
         */
        u0 = A->p[i];
        u1 = (d[0] + u0 * B->p[0]) * mm;

        mpi_mul_hlp(m, B->p, d, u0);
        mpi_mul_hlp(n, N->p, d, u1);

        *d++ = u0;
        d[n + 1] = 0;
    }

    mcpy(A->p, d, n * ciL);
    d[n] += 1;
    d[n] -= mpi_sub_hlp(n, d, N->p);
    mpi_safe_cond_assign(n, A->p, d, (unsigned char)d[n]);
}

/*
 * Montgomery reduction: A = A * R^-1 mod N
 *
 * See mpi_montmul() regarding constraints and guarantees on the parameters.
 */
static void mpi_montred(mbedtls_mpi *A, const mbedtls_mpi *N,
                        mbedtls_mpi_uint mm, const mbedtls_mpi *T)
{
    mbedtls_mpi_uint z = 1;
    mbedtls_mpi U;

    U.n = U.s = (int)z;
    U.p = &z;

    mpi_montmul(A, &U, N, mm, T);
}

static int mbedtls_mpi_read_binary(memctrl *ctl, mbedtls_mpi *X, unsigned char *buf, ulong buflen)
{
    int ret = 0;
    ulong i;

    ret = mbedtls_mpi_alloc(ctl, X, CHARS_TO_LIMBS(buflen));

    if (ret != 0)
    {
        return ret;
    }

    for (i = 0; i < buflen; i++)
        X->p[i / ciL] |= ((mbedtls_mpi_uint)buf[buflen - 1 - i]) << ((i % ciL) << 3);

    return (ret);
}

static int mbedtls_mpi_write_binary(const mbedtls_mpi *X,
                                    unsigned char *buf, ulong buflen)
{
    ulong i;

    clear(buf, buflen);

    for (i = 0; i < X->n * ciL; i++)
    {
        unsigned char byte_i = (((X)->p[(i) / ciL] >> (((i) % ciL) * 8)) & 0xff);
        if (i >= buflen)
        {
            if (byte_i != 0)
            {
                return MBEDTLS_ERR_MPI_BUFFER_TOO_SMALL;
            }
        }
        else
        {
            buf[buflen - 1 - i] = byte_i;
        }
    }

    return (0);
}

static int mbedtls_mpi_get_bit(const mbedtls_mpi *X, ulong pos)
{

    if (X->n * biL <= pos)
        return (0);

    return ((X->p[pos / biL] >> (pos % biL)) & 0x01);
}

static ulong mbedtls_clz(const mbedtls_mpi_uint x)
{
    ulong j;
    mbedtls_mpi_uint mask = (mbedtls_mpi_uint)1 << (biL - 1);

    for (j = 0; j < biL; j++)
    {
        if (x & mask)
            break;

        mask >>= 1;
    }

    return j;
}

static ulong mbedtls_mpi_bitlen(const mbedtls_mpi *X)
{
    ulong i, j;

    if (X->n == 0)
        return (0);

    for (i = X->n - 1; i > 0; i--)
        if (X->p[i] != 0)
            break;

    j = biL - mbedtls_clz(X->p[i]);

    return ((i * biL) + j);
}

/*
 *  X = A^E mod N
 *  slow inplementation,just for simple use
 */
static int mbedtls_mpi_exp_mod(mbedtls_mpi *X, const mbedtls_mpi *A,
                               const mbedtls_mpi *E, const mbedtls_mpi *N,
                               mbedtls_mpi *RR, mbedtls_mpi *Y, mbedtls_mpi *T)
{
    unsigned int i;
    mbedtls_mpi_uint mm;
    int z = 0;

    mpi_montg_init(&mm, N);

    mcpy(Y->p, A->p, A->n * ciL);
    // Y = A*R mod N
    mpi_montmul(Y, RR, N, mm, T);

    for (i = 1; i < mbedtls_mpi_bitlen(E); i++)
    {
        // Y = Y * Y * R^-1 mod N
        mpi_montmul(Y, Y, N, mm, T);
        if (mbedtls_mpi_get_bit(E, i))
        {
            if (z == 0)
            {
                mcpy(X->p, Y->p, Y->n * ciL);
            }
            else
            {
                mpi_montmul(X, Y, N, mm, T);
            }
            z++;
        }
    }

    if (mbedtls_mpi_get_bit(E, 0))
    {
        if(z==0)
        {
            mcpy(X->p, Y->p, Y->n * ciL);
        }else
        {
            mpi_montmul(X, A, N, mm, T);
        }
        z++;
    }

    return 0;
}

int rsa_process(unsigned char *pheap, int heapsize,
            unsigned char *n,
            unsigned char *rr,
            unsigned char *ed,
            unsigned char *sig,
            unsigned char *dst, int dst_size)
{
    mbedtls_mpi A, N, U, RR, T, Y, E;
    int ret = 0;
    memctrl *ctrl;

    ctrl = mbedtls_set_heap(pheap, heapsize);

    ret |= mbedtls_mpi_read_binary(ctrl, &N, n,   dst_size);
    ret |= mbedtls_mpi_read_binary(ctrl, &RR, rr, dst_size);
    ret |= mbedtls_mpi_read_binary(ctrl, &A, sig, dst_size);
    ret |= mbedtls_mpi_read_binary(ctrl, &E, ed,  dst_size);

    ret |= mbedtls_mpi_alloc(ctrl, &T, (N.n + 1) * 2);
    ret |= mbedtls_mpi_alloc(ctrl, &U, (N.n + 1));
    ret |= mbedtls_mpi_alloc(ctrl, &Y, (N.n + 1));

    if (ret != 0)
    {
        return MBEDTLS_ERR_MPI_ALLOC_FAILED;
    }

    ret = mbedtls_mpi_exp_mod(&U, &A, &E, &N, &RR, &Y, &T);
    if (ret != 0)
    {
        return ret;
    }
    return mbedtls_mpi_write_binary(&U, dst, dst_size);
}

// 公钥 (N,E)
static unsigned char N[] = {
    0x87, 0x82, 0x6b, 0x23, 0x76, 0x52, 0x1f, 0x8f, 0xeb, 0xba, 0xd4, 0x30, 0xf0, 0x9b, 0x2f, 0xf3,
    0xba, 0x39, 0x5b, 0xa8, 0x42, 0x8e, 0xff, 0xb8, 0x99, 0x74, 0x0f, 0xd9, 0x8d, 0x50, 0xed, 0x50,
    0x7b, 0x4d, 0x2d, 0x6c, 0x32, 0x6d, 0xf2, 0xe6, 0x6a, 0x00, 0x00, 0x2b, 0x1b, 0x9a, 0xc0, 0x6e,
    0xe6, 0x8f, 0xc0, 0xa4, 0xec, 0xb2, 0x56, 0xa7, 0xfa, 0x3b, 0xde, 0x6b, 0x71, 0x30, 0xe4, 0xfc,
    0xe5, 0xf0, 0x8d, 0x36, 0x3f, 0x7c, 0xdf, 0x8c, 0xd8, 0xf5, 0x70, 0xe4, 0xb7, 0xca, 0xcc, 0x51,
    0xe7, 0x38, 0xd0, 0x6a, 0x57, 0xa2, 0x78, 0x07, 0xd4, 0x89, 0xc8, 0xb8, 0xc5, 0xa5, 0x4b, 0x16,
    0x95, 0xb2, 0xb5, 0xd5, 0xd2, 0xb9, 0x96, 0x40, 0x26, 0x12, 0xe1, 0x4b, 0x31, 0x6b, 0xe2, 0x7d,
    0x94, 0xc5, 0x39, 0xa3, 0xb7, 0x3c, 0x3e, 0x84, 0xaf, 0xa2, 0x93, 0x63, 0x23, 0xcd, 0x93, 0x8b,
    0x28, 0x7b, 0x17, 0x3e, 0x0b, 0x5f, 0xda, 0xe0, 0x88, 0x5a, 0x52, 0xa9, 0xdf, 0x86, 0xc3, 0x4f,
    0xcd, 0x0d, 0x58, 0x6b, 0xdf, 0x6c, 0x1b, 0x56, 0x14, 0x17, 0x70, 0x2d, 0x7e, 0xaf, 0x47, 0xd3,
    0xb9, 0xa6, 0x02, 0x1e, 0xad, 0x05, 0x63, 0x03, 0x1f, 0xb7, 0xe5, 0xaf, 0xe8, 0x89, 0xd0, 0x38,
    0x52, 0x38, 0xd9, 0x84, 0x57, 0x35, 0x98, 0xeb, 0xde, 0xe9, 0x89, 0xbb, 0x3e, 0xca, 0x97, 0x82,
    0x06, 0x4f, 0x92, 0x2e, 0x59, 0x7a, 0x98, 0xa5, 0x74, 0x90, 0x7f, 0x96, 0x4b, 0x2b, 0xe8, 0xa2,
    0x65, 0xf7, 0x54, 0x7a, 0x72, 0x2f, 0x9f, 0xdb, 0x3d, 0x60, 0x70, 0xca, 0x76, 0xf4, 0xfb, 0xab,
    0x49, 0x85, 0x4c, 0x9b, 0x95, 0x5a, 0x12, 0xc5, 0xeb, 0xe2, 0x47, 0xcd, 0x3c, 0x43, 0x4e, 0xa0,
    0x66, 0x7d, 0x86, 0xd2, 0xe9, 0x4d, 0x35, 0x4e, 0x6c, 0xf7, 0x68, 0x42, 0x9a, 0x3c, 0x85, 0xd1};

static unsigned char E[] = {
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x01};

//私钥 (N,D)
static unsigned char D[] = {
    0x1e, 0x09, 0x83, 0xb4, 0x2d, 0xa3, 0x10, 0x89, 0xf7, 0x67, 0xc7, 0x67, 0x3d, 0xbe, 0x38, 0x87,
    0xdf, 0x0c, 0x9d, 0xcb, 0x93, 0x4d, 0x5d, 0x53, 0xce, 0xf8, 0x12, 0x17, 0x58, 0x22, 0xcb, 0x27,
    0xde, 0xdd, 0x01, 0xa7, 0x8d, 0x1a, 0x20, 0x10, 0x81, 0x08, 0x95, 0x00, 0xf9, 0x32, 0x79, 0x5b,
    0x5b, 0xd2, 0x1b, 0x92, 0xb3, 0x40, 0xe8, 0xc2, 0x7d, 0x4e, 0x4e, 0x04, 0x24, 0xe8, 0x00, 0xaa,
    0x2a, 0x52, 0x03, 0x0b, 0x36, 0x51, 0x78, 0xc0, 0x20, 0xcb, 0x6f, 0x05, 0xd3, 0xd3, 0xa9, 0x2c,
    0xb2, 0x83, 0x3e, 0x77, 0x84, 0x0b, 0x68, 0x6d, 0xdb, 0xe7, 0xda, 0xcd, 0x52, 0x4a, 0x4c, 0x75,
    0xaa, 0x23, 0x1d, 0xf9, 0x52, 0xa7, 0x7e, 0xad, 0xa3, 0x82, 0xe5, 0xdb, 0xa4, 0x0d, 0xd4, 0xfb,
    0x9f, 0x41, 0x84, 0x80, 0x4c, 0xba, 0x96, 0xe5, 0x14, 0x85, 0x86, 0x04, 0x20, 0xc8, 0x8d, 0xde,
    0xa5, 0x2d, 0xa5, 0xc4, 0x49, 0xbc, 0xd1, 0xea, 0x69, 0x0d, 0x95, 0xe0, 0x8a, 0x01, 0x22, 0xb1,
    0x20, 0x0a, 0xd4, 0xe3, 0x1e, 0xa6, 0x60, 0x84, 0x1c, 0x83, 0xce, 0x52, 0x96, 0xa3, 0x44, 0x51,
    0xe2, 0x34, 0x81, 0x2c, 0xdb, 0x98, 0x7a, 0x3d, 0xb9, 0x03, 0xef, 0xec, 0x6e, 0xd6, 0xe0, 0x25,
    0x6b, 0x4f, 0x01, 0xc3, 0xc4, 0xd4, 0xed, 0x58, 0xc9, 0xe6, 0x98, 0x57, 0xd3, 0x4d, 0xba, 0xe7,
    0x41, 0x68, 0xc8, 0x0d, 0x83, 0xd3, 0xb5, 0x9e, 0xa3, 0x0b, 0xe2, 0x3b, 0xfd, 0xac, 0xc1, 0xab,
    0x63, 0xbd, 0xa5, 0x4b, 0x68, 0xce, 0x20, 0xff, 0xbb, 0xa0, 0x81, 0x35, 0x56, 0x1d, 0x2f, 0xdc,
    0xd1, 0x7a, 0x0a, 0x19, 0x6d, 0x4a, 0x2d, 0x0d, 0xf0, 0xe2, 0x23, 0x70, 0x5d, 0x65, 0x41, 0x7c,
    0x8b, 0x49, 0x8c, 0x54, 0x31, 0x1c, 0x5b, 0x66, 0x84, 0xdf, 0x41, 0x87, 0xf8, 0x73, 0xef, 0x91};

//  rr = R*R mod N
// 根据公钥N 预先计算好的数据，为了加快解密速度,同时减少代码体积
static unsigned char RR[] = {

    0x73, 0x1b, 0x0e, 0xfd, 0xd5, 0x89, 0x02, 0xbd, 0x8e, 0xb9, 0x36, 0x70, 0x78, 0x6c, 0xad, 0x9b,
    0xc8, 0xa6, 0x5c, 0xf9, 0xee, 0x29, 0xbc, 0xbc, 0xa3, 0x61, 0x06, 0x6c, 0x98, 0xc9, 0xaa, 0x21,
    0x4b, 0xb3, 0xf4, 0x03, 0xc5, 0x00, 0xfa, 0xa4, 0xe5, 0xeb, 0x96, 0x70, 0x82, 0x2c, 0x18, 0x5b,
    0x34, 0xeb, 0x77, 0x9f, 0x05, 0x92, 0x89, 0x25, 0xb5, 0x8b, 0x29, 0x85, 0x9e, 0x21, 0x60, 0x57,
    0xa7, 0x8e, 0x90, 0x89, 0x1b, 0xb2, 0x86, 0x8f, 0x6d, 0x18, 0xc9, 0xcd, 0xec, 0x2b, 0x47, 0xc2,
    0xf7, 0xfa, 0xaa, 0x92, 0xac, 0xc4, 0x64, 0x58, 0x6f, 0x2f, 0xb4, 0xcf, 0x27, 0xd2, 0xad, 0x43,
    0x46, 0x65, 0x49, 0x41, 0x8d, 0x15, 0xa0, 0xd1, 0x25, 0x4b, 0x00, 0x1e, 0xea, 0x43, 0x5f, 0xb9,
    0xd6, 0x16, 0x77, 0x41, 0x85, 0x0e, 0xec, 0x4a, 0x26, 0x3f, 0x11, 0x50, 0x4e, 0x96, 0x4f, 0x40,
    0xa7, 0xbc, 0x95, 0xa8, 0xb8, 0x9d, 0x86, 0xa9, 0x7d, 0x69, 0x85, 0x2a, 0xaf, 0x3e, 0x52, 0x0e,
    0x51, 0x6f, 0x6d, 0x31, 0x73, 0x6a, 0xa6, 0x66, 0x02, 0x31, 0xe4, 0x3a, 0xef, 0x7e, 0xe3, 0xe7,
    0x6b, 0xa0, 0x6a, 0x67, 0x0a, 0xf9, 0xde, 0x77, 0x89, 0x99, 0x2b, 0x0f, 0xe9, 0x08, 0x90, 0x46,
    0xe5, 0x97, 0x98, 0x75, 0x50, 0xc9, 0xdb, 0x1c, 0xba, 0x60, 0x26, 0x4f, 0x89, 0xbc, 0xf3, 0x7b,
    0x36, 0xa9, 0x69, 0x1a, 0x4a, 0x14, 0x57, 0x4f, 0x44, 0x7b, 0x02, 0x69, 0xcd, 0xa2, 0x4e, 0xc7,
    0xb3, 0xb4, 0x58, 0x9d, 0xce, 0xd2, 0x68, 0xd5, 0x0d, 0x1e, 0x47, 0x47, 0x7b, 0xd2, 0x61, 0x84,
    0x23, 0x01, 0x8b, 0x26, 0xfd, 0xf9, 0x96, 0x11, 0x8a, 0x23, 0x19, 0xb1, 0xfa, 0xdc, 0xea, 0x75,
    0x6b, 0x9c, 0x74, 0xc0, 0x2c, 0xfe, 0x8a, 0xa8, 0xe9, 0xde, 0xbd, 0x11, 0xc8, 0xd2, 0x95, 0x76};



static unsigned char src[] = {

    0x00, 0x58, 0xd3, 0xbc, 0x5b, 0xd6, 0x81, 0x5e, 0xd9, 0x84, 0x61, 0xd2, 0xbb, 0x5a, 0xd5, 0x80,
    0x5d, 0xd8, 0x83, 0x60, 0xdb, 0xba, 0x59, 0xd4, 0xbd, 0x5c, 0xd7, 0x82, 0x5f, 0xda, 0x85, 0x58,
    0xd3, 0xbc, 0x5b, 0xd6, 0x81, 0x5e, 0xd9, 0x84, 0x61, 0xd2, 0xbb, 0x5a, 0xd5, 0x80, 0x5d, 0xd8,
    0x83, 0x60, 0xdb, 0xba, 0x59, 0xd4, 0xbd, 0x5c, 0xd7, 0x82, 0x5f, 0xda, 0x85, 0x58, 0xd3, 0xbc,
    0x5b, 0xd6, 0x81, 0x5e, 0xd9, 0x84, 0x61, 0xd2, 0xbb, 0x5a, 0xd5, 0x80, 0x5d, 0xd8, 0x83, 0x60,
    0xdb, 0xba, 0x59, 0xd4, 0xbd, 0x5c, 0xd7, 0x82, 0x5f, 0xda, 0x85, 0x58, 0xd3, 0xbc, 0x5b, 0xd6,
    0x81, 0x5e, 0xd9, 0x84, 0x61, 0xd2, 0xbb, 0x5a, 0xd5, 0x80, 0x5d, 0xd8, 0x83, 0x60, 0xdb, 0xba,
    0x59, 0xd4, 0xbd, 0x5c, 0xd7, 0x82, 0x5f, 0xda, 0x85, 0x58, 0xd3, 0xbc, 0x5b, 0xd6, 0x81, 0x5e,
    0xd9, 0x84, 0x61, 0xd2, 0xbb, 0x5a, 0xd5, 0x80, 0x5d, 0xd8, 0x83, 0x60, 0xdb, 0xba, 0x59, 0xd4,
    0xbd, 0x5c, 0xd7, 0x82, 0x5f, 0xda, 0x85, 0x58, 0xd3, 0xbc, 0x5b, 0xd6, 0x81, 0x5e, 0xd9, 0x84,
    0x61, 0xd2, 0xbb, 0x5a, 0xd5, 0x80, 0x5d, 0xd8, 0x83, 0x60, 0xdb, 0xba, 0x59, 0xd4, 0xbd, 0x5c,
    0xd7, 0x82, 0x5f, 0xda, 0x85, 0x58, 0xd3, 0xbc, 0x5b, 0xd6, 0x81, 0x5e, 0xd9, 0x84, 0x61, 0xd2,
    0xbb, 0x5a, 0xd5, 0x80, 0x5d, 0xd8, 0x83, 0x60, 0xdb, 0xba, 0x59, 0xd4, 0xbd, 0x5c, 0xd7, 0x82,
    0x5f, 0xda, 0x85, 0x58, 0xd3, 0xbc, 0x5b, 0xd6, 0x81, 0x5e, 0xd9, 0x84, 0x61, 0xd2, 0xbb, 0x5a,
    0xd5, 0x80, 0x5d, 0xd8, 0x83, 0x60, 0xdb, 0xba, 0x59, 0xd4, 0xbd, 0x5c, 0xd7, 0x82, 0x5f, 0xda,
    0x85, 0x58, 0xd3, 0xbc, 0x5b, 0xd6, 0x81, 0x5e, 0xd9, 0x84, 0x61, 0xd2, 0xbb, 0x5a, 0xd5, 0x80};


#include <stdio.h>

int main(void)
{
    int ok = 0;
    int i = 0;

    unsigned char heap[4096];
    unsigned char encryped[256];
    unsigned char decryped[256];

    //私钥加密
    rsa_process(heap,4096,N,RR,D,src,encryped,256);
    //公钥解密
    rsa_process(heap,4096,N,RR,E,encryped,decryped,256);

    for (i = 0; i < 256; i++)
    {
        if (decryped[i] != src[i])
        {
            ok=-1;
            break;
        }
    }
    printf("private encrypt test result %d\n",ok);

    //公钥加密
    rsa_process(heap,4096,N,RR,E,src,encryped,256);
    //私钥解密
    rsa_process(heap,4096,N,RR,D,encryped,decryped,256);

    for (i = 0; i < 256; i++)
    {
        if (decryped[i] != src[i])
        {
            ok=-1;
            break;
        }
    }
    printf("public encrypt test result %d\n",ok);

    return 0;
}
